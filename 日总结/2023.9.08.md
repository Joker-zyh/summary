# 算法

​	今天完成了4道算法题，分别是最长递增子序列，最长连续递增序列，最长重复子数组，最长公共子序列。

​	 **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。 

​	使用动态规划解题，第一题设dp[i] 是以nums[i] 结尾子序列的最长子序列，初始化全为1，遍历长度在 [0,i-1] 的字符串。如果nums[i] > nums[j] 时 dp[i] = Math.max(dp[i],dp[j]+1);

​	最长连续递增序列是上一题的变式，要求连续，那么 如果 nums[i] > nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。  即：dp[i] = dp[i - 1] + 1; 

​	最长重复子数组，子数组可以不连续，dp[i] [j]  表示 以i-1结尾的A，和以j-1结尾的B，最长重复子数组长度。初始化dp[0] [0] = 0。双重for循环遍历两个字符串，当nums1[i-1] == nums2[j-1]时dp[i][j] = dp[i-1] [j-1] + 1;

​	最长公共子序列，dp[i] [j] 表示 长度为i-1的text1与长度为j-1的text2的最长公共子序列。当text1.charAt(i-1) == text2.charAt(j-1)时，dp[i] [j] = dp[i-1] [j-1] + 1。否则dp[i] [j] = Math.max(dp[i-1] [j],dp[i] [ j-1]);dp[i] [j] 由3种状态推出。

# Spring

​	1、今天首先复习了反射，学习了获取类的三种方法，获取类的构造器，类的成员变量和成员方法。

​	2、又复习了注解，注解即java代码里的特殊标记。自定义注解，元注解和注解解析（判断类上、方法上、成员变量上是否存在注解，并把注解里的内容解析出来）（通过反射）。



​	3、最后学习了IoC注解，其目的是简化xml的配置，通过声明bean的注解，负责属性输入的注解和配置类来代替xml文件。

​	声明bean的注解有四个Controller，Service，Repository其都是Component的别名（为了提高代码的可读性）。

​	负责属性输入的注解，注入简单类型时使用@Value。注入复杂类型时使用 @Autowried和@Qulifier 或者 @Resource（默认根据名称装配，若未指定则根据属性名装配，若没有匹配的再根据类型装配），推荐使用@Resource。

​	配置类，要添加@Configration注解和@ComponentScan（“扫描的包名”，“扫描的包名”......）。

# 明日计划

​	代码随想录四道题

​	Spring中JDBC章节

​	英语单词

​	