# 算法

## 栈与队列

1. 用栈实现队列：

   1. 利用两个栈，一个作为输入栈，一个作为输出栈。当要输出队头元素时，若输出栈为空，就将输入栈的元素压入输出栈，然后输出栈头元素即可。查看队头元素同理。

2. 用队列实现栈：

   1. 只用一个队列，当要输出或查看栈顶元素时，依次出队再入队，直至队尾元素成为队首元素，其余元素顺序不变。

3. 有效的括号（**括号匹配问题**）：

   1. 概括：括号匹配，（），【】，{}。
   2. 有三种不匹配的情况，要仔细分辨。
   3. 在入栈时，当拿到的是左括号时，将右括号入栈，这样在后边判断相等时方便。

4. 删除字符串中的所有相邻重复项（**字符串去重问题，匹配问题都是栈的强项**）：

   1.  思路就是可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。 

5. 逆波兰表达式问题：

   1. 碰到一个符号就匹配来个元素，**匹配问题都是栈的强项**。
   2. 注意在减法和除法时弹出的两元素，哪个是被减数，哪个是减数。

6. 滑动窗口最大值：

   1. 在本题中要使用单调队列，主要思想是**队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。**
   2. 那么这个维护元素单调递减的队列就叫做**单调队列，即单调递减或单调递增的队列。**
   3. 设计单调队列：
      1. pop(value)：如果窗口移除的元素value等于单调队列的队首元素，那么队列弹出元素，否则不用任何操作
      2. push(value)：如果push的元素value大于队尾元素的数值，那么就将队尾的元素弹出，直到push元素的数值小于等于队队尾元素的数值为止
   4.  **单调队列不是一成不变的，而是不同场景不同写法**，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。 

7. ### **求前k个高频元素**：

   1. 本题要使用优先级队列， **就是一个披着队列外衣的堆** ， 因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。 

   2. > 什么是优先级队列呢？
      >
      > 其实**就是一个披着队列外衣的堆**，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。
      >
      > 而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？
      >
      > 缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。
      >
      > 什么是堆呢？
      >
      > **堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。
      >
      > 所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。
      >
      > 本题就要**使用优先级队列来对部分频率进行排序。** 注意这里是对部分数据进行排序而不需要对所有数据排序！

   3. ```java
          public int[] topKFrequent(int[] nums, int k) {
              Map<Integer,Integer> map = new HashMap<>();
              for (int i :nums) {
                  map.put(i,map.getOrDefault(i,0)+1);
              }
      
              //comparator接口，返回值为负数，第一个参数在前，返回值为正，第二个参数在前
              //所以从大到小排序，arg2 - arg1.
              //从小到大排序，arg1 - arg2.
              PriorityQueue<int[]> priorityQueue = new PriorityQueue<>(new Comparator<int[]>() {
                  @Override
                  public int compare(int[] o1, int[] o2) {
                      return o2[1] - o1[1];
                  }
              });
      
              //队列从头到尾，数值从大到小，这是大顶堆。
              map.entrySet().forEach(entry -> {
                  priorityQueue.add(new int[]{entry.getKey(),entry.getValue()});
              });
      
              int[] ans = new int[k];
              for (int i = 0; i < k; i++) {
                  ans[i] = priorityQueue.poll()[0];
              }
              return ans;
      
          }
      ```

      