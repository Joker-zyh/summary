# 算法

### 今天完成了三道图论题，即

* 岛屿的最大面积
* 飞地的数量
* 被围绕的区域

都是使用广度优先遍历来解决的，明天使用深度优先遍历来解决他们。

### 对于图论来说，

* 遍历方式很重要，做题时只要熟悉遍历方式，能够辨别出本题使用什么遍历方式并熟练写出就可以说本题成功了一半。

* 如果题目给的是一个二维数组，那么就要定义一个二维数组来表示四个方向 

* ```java
  [] dif = {new int[]{0,1},new int[]{1,0},new int[]{0,-1},new int[]{-1,0}};
  ```

* **对于有些题目不要求返回原二维数组（即岛屿的最大面积，飞地的数量），那么就可以使用沉没岛屿的方法来代替标记数组，即**

* ```java
  if (board[nextX][nextY] == 'O' && !visited[nextX][nextY]){
                      visited[nextX][nextY] = true;
                      queue.add(new int[]{nextX,nextY});
                  }
  //替换为
  if (grid[nextX][nextY] == 1){
                      grid[nextX][nextY] = 0;
                      deque.push(new int[]{nextX,nextY});
                  }
  ```

* **但对于要求返回原数组的题目（即被围绕的区域），还是得使用标记数组，所以两种方法都得会。**

### 这三道题的特殊点

1. 岛屿的最大面积是求**存在的岛屿中最大的那个的面积**，这就要求我们在每次标记岛屿时都要记录其面积，然后和最大值比较。
2. 飞地的数量要求我们求出**不和边缘岛屿相连的岛屿的数量**，该题可以使用沉没岛屿的方法求解，先遍历第一行，第一列，最后一行和最后一列，遇到岛屿就把他及和他相连的岛屿全部沉没，然后遍历二维数组，只要碰见岛屿，就说明该岛屿无法飞出。
3. 被围绕的区域**和飞地的数量类似**，都是求**不能联通到边缘岛屿的岛屿**，但是要返回棋盘，所以不能使用沉没岛屿方法，使用标记数组方法。最后遍历棋盘，遇到没被标记的'O'就把它改为‘X’

### 复习广搜

​	BFS就是先创建队列，把传过来的坐标入队并标记，以其为基点，循环取出队列元素（求出的第一个坐标为传入的坐标），标记取出的元素，再将取出的元素的入队。

​	广搜是队列，不是递归。

# Session，Cookie，ThreadLocal

1. Session
   * 是什么：浏览器从打开到关闭，整个过程成为一次会话。
   * 主要作用是保存会话状态，因为HTTP协议是无状态的
   * 三个域：请求域，会话域，应用域
   * Session主要存储在服务器端，在服务器端有Session列表（实际是一个Map集合）。这个Map集合中key存的是SessionID，Value存的是对应的Session对象。
   * Session实现流程
     * 用户第一次发送请求时，服务器生成一个Session对象，并将对象及其id存入map集合中，之后服务器将session对象的ID发送给浏览器，浏览器将session的ID保存在缓存中。
     * 用户第二次发送请求时，会将浏览器缓存中存储的请求路径对应的SessionID自动发送给服务器，服务器获取到session对象的ID后，从session列表中查找对应的Session对象。
   * Session的ID是以Cookie的形式保存在浏览器内存中的。
   * Session销毁机制：超时销毁和手动销毁。
   * Cookie禁用后可以通过URL重写机制实现session。
2. Cookie
   * Cookie可以保存在浏览器运行内存上（浏览器关闭Cookie就消失），也可以保存在硬盘文件里（永久保存）。
   * Cookie和session都是为了保存会话状态。
   * 在HTTP协议中，任何一个Cookie都是由name和value组成的，name和value都是字符串类型的。
   * Java中的Cookie：
     * setMaxAge（）设置Cookie的有效时间，只要设置的时间大于0，这个Cookie一定会保存在硬盘文件中。
     * setPath（），Cookie关联的路径。
     * request.getCookies（），返回对应路径下的所有Cookie。
3. ThreadLocal
   * 线程安全
   * set，get，remove方法。